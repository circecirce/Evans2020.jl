#big loop de popo

# Print computation time
#total_time = time.process_time() - start_time
#funcs.print_time(total_time, 'All cases-simulations')

#telecharger python voir ce que ca fait et si je fais la meme
default_p1 = append!(zeros(Bool, (H_ind, risk_type_ind, risk_val_ind, avgrtp1_ind,
                        avgrbart_ind, S, 1)),
              default_arr[:, :, :, :, :, :, 1:], axis=6) #pas fini
zt_arr_macro = repeat(reshape(zt_arr,(1, 1, 3, avg_rtp1_size,
                                       avg_rbart_size, S, T),
                       (Hbar_size, 2, 1, 1, 1, 1, 1))

Kt_arr = (1 - default_p1) * k2t_arr
Y_args = (nvec, epsilon, alpha)
Yt_arr = (1 - default_p1) * get_Y(Kt_arr, zt_arr_macro, Y_args)
Ct_arr = (1 - default_p1) * get_C(c1t_arr, c2t_arr)

dict_params = Dict(
        "yrs_in_per" => yrs_in_per,
        "beta_an" => beta_an,
        "beta" => beta,
        "gamma" => gamma,
        "c_min" => c_min,
        "K_min" => K_min,
        "nvec" => nvec,
        "n1" => nvec[0],
        "n2" => nvec[1],
        "alpha" => alpha,
        "epsilon" => epsilon,
        "delta_an" => delta_an,
        "delta" => delta,
        "rho_an" => rho_an,
        "rho" => rho,
        "mu_an" => mu_an,
        "sigma_an" => sigma_an,
        "sigma" => sigma,
        "mu" => mu,
        "A_min" => A_min,
        "z_min" => z_min,
        "Hbar_vec" => Hbar_vec,
        "Hbar_size" => Hbar_size,
        "Hbar" => Hbar,
        "tau" => tau,
        "T" => T,
        "S" => S,
        "rand_seed" => rand_seed,
        "max_cores" => max_cores,
        "num_workers" => num_workers,
        "avg_rtp1_size" => avg_rtp1_size,
        "avg_rtp1_an_vec" => avg_rtp1_an_vec,
        "avg_Rtp1_vec" => avg_Rtp1_vec,
        "avg_rbart_size" => avg_rbart_size,
        "avg_rbart_an_vec" => avg_rbart_an_vec,
        "avg_Rbart_vec" => avg_Rbart_vec,
        "avgRtp1_mat" => avgRtp1_mat,
        "avgRbart_mat" => avgRbart_mat,
        "avgRtp1_gt_avgRbart" => avgRtp1_gt_avgRbart,
        "mu_vec" => mu_vec,
        "mu_mat" => mu_mat,
        "mu_arr" => mu_arr,
        "beta_vec" => beta_vec,
        "beta_mat" => beta_mat,
        "gamma_mat" => gamma_mat,
        "x1_mat" => x1_mat,
        "x1_arr" => x1_arr,
        "kbar2_mat" => kbar2_mat,
        "sigma_vec" => sigma_vec,
        "ExpA" => ExpA)

    dict_endog = Dict(
        "unif_mat" => unif_mat,
                "zt_arr" => zt_arr ,
                "c1t_arr" =>  c1t_arr,
                "c2t_arr"=>  c2t_arr,
                "ut_arr" =>  ut_arr,
                "Ht_arr" =>  Ht_arr,
                "wt_arr" =>  wt_arr,
                "rt_arr" =>  rt_arr,
                "rbart_arr" =>  rbart_arr,
                "rbart_an_arr" => rbart_an_arr,
                "k2t_arr" =>  k2t_arr,
                "EulErr_arr" =>  EulErr_arr,
                "PathTime_arr" =>  PathTime_arr,
                "Kt_arr" => Kt_arr,
                "Yt_arr"=> Yt_arr,
                 "Ct_arr" => Ct_arr,
                "default_arr" =>  default_arr,
                "s_ind_arr" =>  s_ind_arr,
                "total_time" => total_time) #pas sure qu on run total time

                #ca
results_sims = Dict("dict_params" => dict_params, "dict_endog" => dict_endog)
outputfile = os.path.join(output_dir, "results_sims.pkl") #lol wat
pickle.dump(results_sims, open(outputfile, "wb")) #lol wat --> aller regarder si y a un file wb
#pickle.dump(pythonObject, pickleDestination, pickle_protocol=None, *, fix_imports=True)
#c
